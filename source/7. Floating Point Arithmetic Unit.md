# 7. Floating Point Arithmetic Unit
```text
浮点运算单元
AP SHANTHI博士

 

该模块的目标是讨论对浮点数的需求、用于浮点数的标准表示，并讨论如何执行加、减、乘和除等各种浮点算术运算。

 

浮点数和运算

 

表示

 

当您必须表示非常小或非常大的数字时，不动点表示将行不通。将失去准确性。因此，您将不得不查看浮点表示，其中假定二进制小数点是浮动的。当您考虑十进制数 12.34 * 107 时，也可以将其视为 0.1234 * 109，其中 0.1234 是定点尾数。另一部分代表指数值，表示二进制小数点的实际位置在分数中所指示二进制小数点的右（左）9位。由于二进制小数点可以移动到任意位置，并且指数值可以适当调整，因此称为浮点表示。按照惯例，您通常会采用标准化表示，其中浮点数位于第一个非零（有效）数字的右侧。不需要明确指定基数，符号、有效数字和带符号指数构成表示。

 

IEEE（电气和电子工程师协会）制定了浮点运算标准。该标准规定了如何表示单精度（32 位）和双精度（64 位）浮点数，以及如何对它们进行算术运算。IEEE 单精度浮点标准表示需要一个 32 位字，可以表示为从 0 到 31，从左到右编号。第一位是符号位 S，接下来的八位是指数位“E”，最后 23 位是小数“F”。存储的值不是有符号指数 E，而是一个无符号整数 E' = E + 127，称为超额 127 格式。因此，E' 在 0 £ E' £ 255 的范围内。

 

S E'E'E'E'E'E'E'E' FFFFFFFFFFFFFFFFFFFFFFF

 

0 1 8 9 31

 

由单词表示的值 V 可以确定如下：

 

如果 E' = 255 且 F 非零，则 V = NaN（“非数字”）
如果 E' = 255 且 F 为零且 S 为 1，则 V = -Infinity
如果 E' = 255 且 F 为零且 S 为 0，则 V = Infinity
如果 0 < E< 255，则 V =(-1)**S * 2 ** (E-127) * (1.F) 其中“1.F”旨在表示通过在 F 前面加上前缀创建的二进制数隐式前导 1 和一个二进制小数点。
如果 E' = 0 且 F 非零，则 V = (-1)**S * 2 ** (-126) * (0.F)。这些是“非标准化”值。
如果 E'= 0 且 F 为零且 S 为 1，则 V = -0
如果 E' = 0 且 F 为零且 S 为 0，则 V = 0
例如，

 

0 00000000 00000000000000000000000 = 0

 

1 00000000 00000000000000000000000 = -0

 

0 11111111 00000000000000000000000 = 无穷大

 

1 11111111 00000000000000000000000 = -无穷大

 

0 11111111 00000100000000000000000 = NaN

 

1 11111111 00100010001001010101010 = NaN

 

0 10000000 00000000000000000000000 = +1 * 2**(128-127) * 1.0 = 2

 

0 10000001 10100000000000000000000 = +1 * 2**(129-127) * 1.101 = 6.5

 

1 10000001 10100000000000000000000 = -1 * 2**(129-127) * 1.101 = -6.5

 

0 00000001 00000000000000000000000 = +1 * 2**(1-127) * 1.0 = 2**(-126)

 

0 00000000 10000000000000000000000 = +1 * 2**(-126) * 0.1 = 2**(-127)

 

0 00000000 00000000000000000000001 = +1 * 2**(-126) *

 

0.00000000000000000000001 = 2**(-149)（最小正值）

 

（非标准化值）

 

 

双精度数：

 

IEEE 双精度浮点标准表示需要 64 位字，可以表示为从 0 到 63，从左到右编号。第一位是符号位 S，接下来的 11 位是多余的 1023 位指数位 E'，最后 52 位是小数 'F'：

 

S E'E'E'E'E'E'E'E'E'E'E'

 

FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

 

0 1 11 12

 

63

 

由单词表示的值 V 可以确定如下：

如果 E' = 2047 且 F 非零，则 V = NaN（“非数字”）
如果 E'= 2047 且 F 为零且 S 为 1，则 V = -Infinity
如果 E'= 2047 且 F 为零且 S 为 0，则 V = Infinity
如果 0 < E'< 2047 则 V = (-1)**S * 2 ** (E-1023) * (1.F) 其中“1.F”用于表示通过在 F 前面加上前缀而创建的二进制数一个隐含的前导 1 和一个二进制小数点。
如果 E'= 0 且 F 非零，则 V = (-1)**S * 2 ** (-1022) * (0.F) 这些是“非标准化”值。
如果 E'= 0 且 F 为零且 S 为 1，则 V = – 0
如果 E'= 0 且 F 为零且 S 为 0，则 V = 0
 

算术单位

 

浮点数的算术运算包括加法、减法、乘法和除法。这些操作是用类似于符号幅度整数的算法完成的（因为表示的相似性）——例如，只添加相同符号的数字。如果数字是相反的符号，必须做减法。

 

添加

 

以科学记数法给出的十进制值示例：

 

3.25 x 10 ** 3

+ 2.63 x 10 ** -1

——————

    第一步：对齐小数点

第二步：添加

 

3.25 x 10 ** 3

+ 0.000263 x 10 ** 3

—————————

3.250263 x 10 ** 3

（假定使用无限精度，不考虑准确性）

 

第三步：对结果进行归一化（已经归一化了！）

 

浮动 pt 示例。以二进制形式给出的值：

 

.25 = 0 01111101 00000000000000000000000

 100 = 0 10000101 10010000000000000000000

添加这些 fl。角 陈述，

 

第一步：对齐小数点

 

将尾数左移 1 位使指数减少 1

 

将尾数右移 1 位会使指数增加 1

 

我们想将尾数右移，因为从尾数掉下来的位应该来自尾数的最低有效端

 

-> 选择移动 .25，因为我们想增加它的指数。

-> 移动 10000101

-01111101

———

00001000 (8) 个名额。

 

0 01111101 00000000000000000000000（原值）

0 01111110 10000000000000000000000（移1位）

（注意隐藏位被转移到尾数的 msb 中）

0 01111111 01000000000000000000000（移动2位）

0 10000000 00100000000000000000000（移动3位）

0 10000001 00010000000000000000000（移动4位）

0 10000010 00001000000000000000000（移动5位）

 

0 10000011 00000100000000000000000（移位6位）

0 10000100 00000010000000000000000（移动7位）

0 10000101 00000001000000000000000（移动8位）

 

 

第 2 步：添加（不要忘记 100 的隐藏位）

 

0 10000101 1.10010000000000000000000 (100)

+ 0 10000101 0.00000001000000000000000 (.25)

——————————————

0 10000101 1.10010001000000000000000

 

第 3 步：标准化结果（将“隐藏位”设为 1）

这个例子已经是这样了。

结果是	0 10000101 10010001000000000000000
 

减法

 

就小数点对齐而言与加法相同

然后是符号mag的减法算法。数字接管。

 

在减去之前，

比较幅度（不要忘记隐藏的位！）

如果操作数的顺序改变，则改变符号位。

 

之后不要忘记对数字进行归一化。

 

 

乘法

 

以科学记数法给出的十进制值示例：

 

3.0 x 10 ** 1

+ 0.5 x 10 ** 2

——————

 

算法：乘以尾数

添加指数

 

3.0 x 10 ** 1

+ 0.5 x 10 ** 2

——————

1.50 × 10 ** 3

 

二进制示例：考虑一个只有 4 位的尾数。

 

 

0 10000100 0100

× 1 00111100 1100

 


 

 

 

 

 

 

 

添加指数：

 

总是添加真正的指数（否则偏差会被添加两次）


分配

它类似于乘法。

在尾数上做无符号除法（不要忘记隐藏位）

减去真指数

 

下面给出浮点加法器单元的组织和算法。


 

下面给出浮点乘法算法。基于前面讨论的步骤的类似算法可用于除法。



 

四舍五入

 

上面讨论的浮点算术运算可能会产生比 1.M 表示的位数更多的结果。在这种情况下，结果必须四舍五入以适合可用的 M 个位置数。用于中间计算以提高结果精度的额外位称为保护位。这只是硬件成本（保留额外位）和速度与累积舍入误差的权衡，因为最终必须舍入这些额外位以符合 IEEE 标准。

 

舍入方法：

截短
 

- 删除超出支持的所有数字

– 1.00100 -> 1.00

四舍五入到下一个值
 

– 1.00100 -> 1.01

向下舍入到之前的值
 

– 1.00100 -> 1.00

– 与负数的截断不同

四舍五入
 

– 舍入到偶数值（LSB 为 0 的数值）

– 1.00100 -> 1.00

– 1.01100 -> 1.10

– 产生零平均偏差

– 默认模式

乘积的位数可能是乘数和被乘数的两倍

– 1.11 x 1.01 = 10.0011

 

对于舍入到最近的偶数，我们需要知道 LSB 右边的值（舍入位）以及舍入位右边的任何其他数字是否为 1（粘滞位）是这些数字的或）。IEEE 标准要求使用比单精度表示中隐含的 24 位（尾数）更不重要的 3 个额外位 - 保护位、舍入位和粘滞位。当为了对齐小数点而移动尾数时，从尾数最低有效端脱落的位将进入这些额外位（保护位、舍入位和粘滞位）。这些位也可以通过乘法中的归一化步骤以及除法中的商（余数）的额外位来设置。保护位和舍入位只是计算中使用的 2 个额外的精度位。粘滞位指示什么是/可能是未保留的较低有效位。如果值 1 被移入粘滞位位置，则粘滞位保持为 1（“粘”在 1 处），尽管进一步移位。

 

总而言之，在他的模块中，我们讨论了对浮点数的需求、表示浮点数的 IEEE 标准、浮点加法/减法、乘法、除法和各种舍入方法。

 

网页链接/支持材料

 

计算机组织，Carl Hamacher、Zvonko Vranesic 和 Safwat Zaky，第 5 版，McGraw-Hill 高等教育，2011 年。
计算机组织与设计——硬件/软件接口，David A. Patterson 和 John L. Hennessy，第 4 版，Morgan Kaufmann，Elsevier，2009 年。
```
