# 38. Multiple Issue Processors I
```text
多问题处理器 I
AP SHANTHI博士

 

本模块的目标是讨论对多问题处理器的需求，查看不同类型的多处理器并讨论各种实现和设计问题。

 

到目前为止，我们已经研究了利用 ILP 的各种硬件和软件技术。我们在流水线实现中可以期望的理想 CPI 仅为 1。如果我们想要进一步降低 CPI，我们需要探索每个时钟周期发出和完成多条指令的选项。例如，如果我们每个时钟周期发出并完成两条指令，理想情况下我们应该得到 0.5 的 CPI。这种处理器被称为多问题处理器。

 

考虑我们熟悉的简单 MIPS 整数管道。当我们查看不同类型的定点和浮点运算时，这会扩展到执行阶段的多个功能单元。我们还可以增加流水线的深度，这可能是由于时钟速度的增加而需要的。现在，在多问题处理器中，我们增加了管道的宽度。几条指令在流水线的前端被提取和解码。向后端的功能单元发出若干指令。假设如果m是一个周期内可以发出的最大指令数，我们就说处理器是m-issue wide。

 

多问题处理器的类型：多问题处理器基本上有两种变体——超标量处理器和 VLIW（超长指令字）处理器。有两种类型的超标量处理器，每个时钟发出不同数量的指令。他们是

使用有序执行的静态调度超标量
使用乱序执行的动态调度超标量
 

相比之下，VLIW处理器发出固定数量的指令，这些指令被格式化为一条大指令或固定指令包，其中指令之间的并行性由指令明确指示。因此，它们也被称为 EPIC-显式并行指令计算机。示例包括 Intel/HP Itanium 处理器。下表总结了各种类型的特征。

 


 

超标量处理器即时决定要发出多少条指令。如果指令是按程序顺序发给后端的，我们就有有序的处理器。有序处理器是静态调度的，即调度是在编译时完成的。静态调度的超标量必须检查发出数据包中的指令与管道中已有的任何指令之间的任何相关性。它们需要大量的编译器帮助才能获得良好的性能，因为编译器完成了为并行执行查找和调度指令的大部分工作。相比之下，动态调度的超标量需要较少的编译器帮助，但需要大量的硬件成本。如果指令可以以任何顺序发送到后端，我们就有乱序 (OOO) 处理器。

 

超标量方法的替代方法是依靠编译器技术来最大限度地减少由于危险引起的潜在停顿。指令在潜在问题包中格式化，因此硬件不需要明确检查相关性。编译器确保问题包中存在依赖关系或指示何时发生依赖关系。这种架构方法被命名为 VLIW。编译器技术提供了硬件更简单的潜在优势，同时通过广泛的编译器技术仍然表现出良好的性能。我们将查看每种类型的多问题处理器的详细信息。本模块将重点介绍超标量处理器，下一个模块将讨论 VLIW 风格的架构。

 

静态调度超标量处理器：在这样的处理器中，我们在问题包中发出指令，指令数量从 0 到 8。假设我们考虑一个 4 问题超标量，那么将从提取单元中取出多达 4 条指令。取指单元可能会也可能不会提供所有四个指令。在问题阶段，所有的危害都在硬件中检查（动态问题能力）。发布包中的指令之间以及包中的指令与已经执行的指令之间的危险需要通过流水线控制逻辑来检查。如果不能发出包中的一条指令，则只发出前面的指令。也就是说，我们看一个有序的问题。

 

危险检查通常需要很长时间，如果它们要在一个时钟周期内完成，那么问题逻辑将决定最小时钟周期时间。为了避免这种情况，问题阶段被分成两个并流水线化。在第一阶段检查同一数据包中指令之间的危险。数据包中的指令和已经在管道中的指令之间的危险在第二步进行检查。阶段。

 

静态调度的超标量 MIPS：让我们假设一个静态调度的超标量 MIPS，并假设每个时钟周期发出两条指令。其中一个是浮点操作，另一个是加载/存储/分支/整数操作。这比任意双重问题要简单得多，要求也更低。

 

对于该处理器，每个时钟周期最多需要提取两条指令。危险检查过程相对简单，因为一个整数和一个 FP 指令的限制消除了问题包中的大多数危险可能性。唯一出现的困难是当整数指令是浮点加载、存储或移动时。这种可能性会导致对浮点寄存器端口的争用，并且当这对指令中的第二条指令依赖于第一条指令时，也可能会产生新的 RAW 危害。最后，选择执行的指令被分派到其适当的功能单元。图 22.1 显示了指令成对进入流水线时的样子。这里，我们假设浮点指令需要三个时钟周期来执行。

 


 

这种超标量 MIPS 的问题如下：

– 正在筹备中的其他硬件
这肯定比单一问题 MIPS 需要更多的硬件
– 乱序完成会导致不精确的中断
浮点指令可以在程序顺序较晚的整数指令之后完成执行
整型指令完成后可以检测到浮点指令异常
几种解决方案，例如早期检测 FP 异常，使用软件机制在恢复执行之前恢复精确的异常状态，以及延迟指令完成直到我们知道不可能发生异常
– 危险处罚可能更长
加载指令的结果不能在同一个时钟周期或下一个时钟周期使用，因此，接下来的三个指令不能在不停止的情况下使用加载结果。采取分支的分支延迟变为两条或三条指令，具体取决于分支是指令对中的第一条还是第二条指令
 

动态调度的超标量 MIPS：正如我们在前面的单问题模块中已经讨论过的，动态调度也是提高多问题处理器性能的一种方法。当应用于超标量处理器时，动态调度不仅可以在存在数据依赖性时提高性能，还可以让处理器潜在地克服问题限制。也就是说，虽然硬件可能无法在一个时钟周期内启动一个以上整数和一个浮点运算的执行，但动态调度可以在指令发布时消除这种限制，至少在硬件用完保留站之前是这样。

 

让我们假设我们想要扩展 Tomasulo 算法以支持对偶问题。必须按顺序向预订站发出指令。否则会导致违反程序语义。我们可以假设可以发出任何指令组合，但这会使指令发出显着复杂化。或者，我们可以将整数和浮点寄存器的数据结构分开。那么我们就可以同时向各自的保留站发出一条浮点指令和一条整型指令，只要两条发出的指令不访问同一个寄存器集即可。已经使用两种不同的方法在动态调度的处理器中每个时钟发出多条指令。他们是：

流水线，以便在一个时钟周期内处理两条指令
增加处理两条指令的逻辑，包括指令之间任何可能的依赖关系。每个时钟发出四条或更多指令的现代超标量处理器通常包括这两种方法——它们都流水线化并拓宽了发出逻辑。
 

现在让我们看看下面显示的简单循环如何在这个双问题处理器上执行。

循环：LD R2, 0(R1) ;R2=数组元素

DADDIU R2,R2,#1 ;增加R2

SD R2, 0(R1) ;存储结果

DADDIU R1,R1,#8 ;增量指针

BNE R2,R3,LOOP ;如果不是最后一个元素则分支

 


 

在第一个时钟周期，下发迭代1的LD和DADDIU指令。LD在第四个时钟周期完成，由于依赖关系，DADDIU在5中执行并在6中写入。在第二个时钟周期中，SD和迭代1的第二个DADDIU被发出。SD在3中计算有效地址，但在7中进行内存写入。分支在时钟周期3中单发，分支在7中解析。迭代2的LD和DADDIU在时钟周期4中发出。但是，它们只有在分支被解析后才执行。因此，LD 以 10 结束，依此类推。整个时间表如图 22.2 所示。

 

带有推测的动态调度超标量 MIPS：动态调度超标量的性能可以通过推测进一步提高。已经针对单问题处理器讨论了推测的概念。这同样适用于多个问题处理器。分支之外的指令不仅被获取和发出，而且被执行。结果放在 ROB 中。当指令被安排提交时，结果从 ROB 写入寄存器文件或内存。支持推测的动态调度器的架构在图 22.3 中重复以供参考。指令经过四个步骤——发出、执行、写入结果和提交。图 22.4 给出了前面讨论的同一循环的三个迭代的完整时间表。

 



除了以下更改外，该计划的生成方式与以前一样：

由于它是推测性执行，因此包括了称为提交的第四阶段。
此外，由于是推测执行，因此分支之后的指令不必等待分支解析。
请注意，即使分支仅在时钟周期 7 中得到解析，以下 LD 指令也会在时钟周期 5 本身中执行。
由于多次发出和执行可能导致在同一时钟周期内完成多条指令，因此假设每个时钟周期有两个 CDB 和两次提交。
实现问题：在使用推测执行动态调度时，必须记住以下几点。我们需要在每个循环中执行以下每个步骤：

o 从指令缓存和分支预测/目标缓冲区中获取一定数量的指令
应用预测
更新未命中预测和缓存未命中的缓冲区
o 从队列中查找可以并行发出的指令
预订站是否可以收集指令？
ROB里面有空位吗？
通过寄存器重命名处理 WAW/WAR 危害
将指令移至 ROB
o 当数据可用时在功能单元执行（周期数因功能单元类型而异）
o 如果当前不忙，则在 CDB 上发送结果
o 国开行瓶颈？
o 提交 ROB 中的下一条指令
将数据转发到注册/存储单元
对于多问题，我们可能希望每个周期提交 > 1 条指令，否则 ROB 会成为潜在的瓶颈
推测的设计问题：有许多设计问题需要考虑。它们将在下面讨论。

我们可以推测多少？
推测的主要优点之一是它将处理可能更早停止管道的事件，例如缓存未命中。然而，如果处理器推测并执行一个代价高昂的事件，如 TLB 未命中，然后发现这不应该被执行，那么推测的优势就会丧失。因此，大多数带有推测的管道将只允许在推测模式下处理低成本的异常事件（例如一级缓存未命中）。如果发生代价高昂的异常事件，例如二级缓存未命中或 TLB 未命中，处理器将等待，直到导致该事件的指令不再是推测性的，然后再处理该事件。虽然这可能会略微降低某些程序的性能，但它避免了其他程序的显着性能损失，

 

2. 通过多个分支进行推测：通常我们假设我们在一个分支上进行推测。如果在解决较早的分支之前有另一个分支进来会发生什么？我们可以跨多个分支进行推测吗？这变得更加复杂并且是一个设计问题。

 

3.窗口大小：如果发布单元必须查看n条指令（n是我们的窗口大小）才能找到可以同时发布的指令，则需要(n-1)2次比较。4 条指令的窗口需要 9 次比较，6 条指令的窗口需要 25 次比较。这些比较必须在很短的时间内进行，以便可以在同一周期内发出指令并将数据转发到保留站和 ROB。这是 1 个周期内的大量工作！现代处理器的窗口大小为 2-8 条指令，但最激进的处理器的窗口大小为 32。

 

总而言之，我们已经研究了对多个问题处理器的需求。我们已经讨论了不同类型的此类处理器。静态调度的超标量是静态调度的，但是是动态发布的，危险检测是在硬件中完成的。另一方面，动态调度的超标量是动态调度的，动态问题和危险检测在硬件中完成。我们还讨论了与超标量处理器相关的实现问题和设计问题。另一种类型的多问题处理器，即 VLIW，将在下一个模块中详细介绍。

 

网页链接/支持材料
计算机组织与设计——硬件/软件接口，David A. Patterson 和 John L. Hennessy，第 4 版，Morgan Kaufmann，Elsevier，2009 年。
Computer Architecture – A Quantitative Approach，John L. Hennessy 和 David A. Patterson，第 5 版，Morgan Kaufmann，Elsevier，2011。
```
