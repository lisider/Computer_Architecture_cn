# 39. Multiple Issue Processors II
```text
多问题处理器 II
AP SHANTHI博士

 

本模块的目标是详细讨论 VLIW 架构，并讨论与 VLIW 架构风格相关的各种实现和设计问题。

 

上一个模块讨论了对多个问题处理器的需求。我们还详细讨论了静态调度和动态调度的超标量。现在，我们将讨论另一种类型的多问题处理器，即 VLIW 处理器。

 

VLIW（超长指令字）处理器：在这种架构风格中，编译器将固定数量的操作格式化为一条大指令（称为包）并对其进行调度。指令数很少，比如 3，它通常被称为LIW（长指令字）。指令集架构发生了变化，即 1 个程序计数器指向 1 个束（不是 1 个操作）。捆绑中的操作是并行发出的。包遵循固定格式，因此解码操作是并行完成的。假设对于可以并行发出的操作类型有足够的 FU。我们还可以查看流水线 FU。遵循这种风格的示例机器包括 1980 年代的 Multiflow & Cydra 5（8 到 16 次操作）、IA-64（3 次操作）、Crusoe（4 次操作）和 TM32（5 次操作）。

 

处理器中硬件设计的主要目标是降低硬件复杂性，缩短周期时间以获得更好的性能并降低功率要求。VLIW 设计通过以下功能降低了硬件复杂性：

更少的多问题硬件
没有依赖检查包中的指令
指令发布槽和 FU 之间的路径可以更少
更简单的指令调度
无乱序执行，无指令分组
理想情况下没有结构危险检查逻辑
所有这些都会降低硬件复杂性，进而影响循环时间和功耗。

 

虽然硬件不那么复杂，但编译器变得更加复杂。我们需要编译器的支持来增加ILP。由于将多个操作打包到一个包中以保持功能单元忙碌，因此代码序列中必须有足够的并行性来填充可用的操作槽。这种并行性通常是通过使用我们在前面模块中讨论的循环展开和软件调度等技术来发现的，然后适当地调度这些指令。如果展开生成直线代码，则可以使用对单个基本块进行操作的本地调度技术。另一方面，如果发现和利用并行性需要跨分支调度代码，则要复杂得多必须使用全局调度算法。全局调度算法不仅在结构上更复杂，而且它们必须在优化中处理明显更复杂的权衡，因为跨分支移动代码是昂贵的。

 

跟踪调度是专为 VLIW 开发的全局调度技术之一。跟踪调度的细节超出了本讲座的范围。但我们将在这里涉及的基本概念。跟踪调度是一种组织全局代码移动过程的方法，通过在不太频繁的路径上产生可能的代码移动成本来简化代码调度。跟踪调度有两个步骤。第一步，称为跟踪选择，试图找到一个可能的基本块序列，这些块的操作将被放在较少数量的指令中，称为跟踪. 将使用循环展开和静态分支预测，以便产生的轨迹是由连接许多基本块而产生的直线序列。选择跟踪后，称为跟踪压缩的第二个过程会尝试将跟踪压缩为少量宽指令。Trace compaction 是代码调度；因此，它尝试在序列（跟踪）中尽早移动操作，将操作打包成尽可能少的宽指令（或发出数据包）。Predication 是一种硬件支持，可以消除一些条件分支，扩展本地调度的有用性并提高全局调度的性能也被广泛使用。

 

因此，可以看出编译器负责发现并行性并检测危险并隐藏与它们相关的延迟。通过确保捆绑中没有两个操作被调度到同一个功能单元，并且没有两个操作被调度到同一个存储体，可以处理结构性危险。在硬件的支持下，与内存相关的延迟通过数据预取和将负载提升到存储之上来处理。通过确保束中的指令之间没有数据危险来处理数据危险。使用预测执行和静态分支预测来处理控制风险。

 

现在让我们看看我们已经熟悉的循环，看看如何在 VLIW 处理器上调度它。下面的代码显示了在 11 个时钟周期内运行的三次展开和调度代码，每次迭代需要 3.67 个时钟周期。

 

1 回路：LD F0,0(R1)

2 LD F6,-8(R1)

3 LD F10,-16(R1)

4 ADD.D F4,F0,F2

5 ADD.D F8,F6,F2

6 ADD.D F12,F10,F2

7 SD 0(R1),F4

8 SD -8(R1),F8

9 DSUBUI R1,R1,#24

10 BNEZ R1,LOOP

11 SD 8(R1),F12 ; 8-24 = -16

 

假设一个 VLIW 处理器在一个包中包含两个内存操作、两个浮点操作和一个整数或分支操作，一个可能的时间表如下图 23.1 所示。

 


 

该循环已展开七次以发现足够的并行性。假设 Load 和使用它的 Add 之间的延迟为 1，并且假设 Add 和相应的 Store 之间的延迟为 2。第一个时钟周期只发出两个加载操作。第二个时钟周期也只发出两个后续的负载。第三个时钟周期发出另外两个负载以及对应于前两个负载的两个 Adda。这是继续。请注意，第一组 Stores 在相应的 Adds 后两个时钟周期发出。请注意，最后一个 Store 使用地址 8(R1) 而不是 -48(R1)，因为 DSUBUI 指令已向前移动并将 R1 修改为 -56。此代码需要 9 个时钟周期进行 7 次迭代，因此每次迭代的速率为 1.3 个时钟。

 

VLIW 处理器的缺点： 对于最初的 VLIW 模型，既有技术问题，也有后勤问题。技术问题是代码量的增加和锁步操作的局限性。代码大小的增加是由于进行了雄心勃勃的展开，也因为我们无法有效地使用插槽。前面讨论的时间表本身表明，只有大约 60% 的功能单元被使用，因此每条指令几乎有一半是空的。在大多数 VLIW 中，如果无法调度任何操作，则可能需要将指令完全留空。为了处理这种代码大小的增加，有时会使用巧妙的编码。例如，可能只有一个大的直接字段供任何功能单元使用。

 

早期的 VLIW 以锁步方式运行，因为根本没有危险检测硬件。因此，任何功能单元管道中的停顿都会导致整个处理器停顿，因为所有功能单元必须保持同步。尽管编译器可能能够调度确定性功能单元以防止停顿，但预测哪些数据访问将遇到缓存停顿并对其进行调度是非常困难的。因此，缓存需要阻塞并且会导致所有功能单元停顿。这限制太大了。在较新的处理器中，功能单元更加独立地运行，并且编译器用于避免发出时的危险，而硬件检查允许在发出指令后不同步地执行。

 

二进制代码兼容性也是 VLIW 的一个主要后勤问题。不同数量的功能单元和功能单元延迟需要不同版本的代码。这一要求使得在连续实现之间或具有不同问题宽度的实现之间迁移，比超标量设计更困难。这种二进制代码兼容性的一种可能解决方案是目标代码转换或仿真。这项技术发展迅速，可以在未来的迁移计划中发挥重要作用。另一种方法是缓和方法的严格性，以便二进制兼容性仍然可行。后一种方法用于 IA-64 体系结构。

 

超标量架构相对于 VLIW 的优势：与 VLIW 架构相比，超标量具有以下优势：

旧代码仍然可以正常运行
o 像那些作为二进制文件出现的工具
硬件检测指令对是否为合法的对偶发布对
o 如果不是，它们将按顺序运行
对代码密度影响不大
o 您不必只用 NOP 来填充无法发出指令的所有位置
编译器问题非常相似
o 仍然需要做指令调度
o 存在动态问题硬件，因此编译器不必过于保守
 

显式并行指令计算 (EPIC)是 HP-Intel 联盟于 1997 年基于 VLIW 架构风格创造的术语。由于 VLIW 处理器发出固定数量的指令，这些指令格式为一个包，指令之间的并行性由指令明确指示，因此它们也被称为显式并行指令计算机。VLIW 和 EPIC 处理器本质上是由编译器静态调度的。Itanium 处理器就是这种架构风格的一个例子。对该架构的完整讨论超出了本讨论的范围。但是，下面列出了该架构的一些特征：

指令包
128 位捆绑
3 个 41 位指令/包
一次可发2个包
完全谓词ISA
寄存器
128 个整数和 FP 寄存器
用于循环展开和类似优化的 128 个附加寄存器
8个间接分支寄存器
杂项其他寄存器
ISA & Microarchitecture 看起来很复杂（乱序处理器的一些特性）
如果一个包中的指令停止，则并非所有指令都需要停止（记分板跟踪生成的源操作数）
多级分支预测
寄存器重新映射以支持“寄存器堆栈”上的轮换寄存器，这有助于软件流水线和动态大小的寄存器窗口
用于“寄存器窗口”溢出检测的特殊硬件；保存和恢复寄存器堆栈的特殊指令
推测状态无法存储到内存中
特殊指令检查整数寄存器毒位以检测值是否是推测性的（推测性加载或异常）
操作系统可以覆盖禁令（例如，用于上下文切换）
浮点的不同机制（状态寄存器）
数组地址后递增和循环控制
 

超标量和 VLIW 处理器之间的比较： 超标量处理器具有更复杂的指令调度硬件，因为它们执行乱序执行，并且指令发布结构和功能单元之间有更多路径。这将导致更慢的循环时间、更多的芯片面积和更多的功耗。如果支持导致相同可能结果的完全预测，VLIW 架构也将具有更多功能单元。VLIW 架构显然具有更大的代码大小。IA-64 代码的估计值是 x86 的 2-4 倍。这将导致指令带宽需求的增加和指令缓存效率的降低。它们还需要更复杂的编译器。超标量可以更有效地执行与管道无关的代码。因此，如果我们更改实现，它们就不必重新编译。

 

总而言之，我们已经研究了对多个问题处理器的需求。我们已经讨论了多问题处理器的 VLIW 风格。VLIW 处理器形成由许多指令组成的指令包，并且这些指令包是静态发布的。危险检测和问题由编译器完成。编译器必须很复杂并且使用不同的技术来利用 ILP。早期的 VLIW 的指令格式非常严格，实际上需要为不同版本的硬件重新编译程序。为了减少这种不灵活性并提高该方法的性能，一些创新已被纳入此类较新的架构中。第二代 VLIW 架构是台式机和服务器市场所采用的方法。

 

网页链接/支持材料
计算机组织与设计——硬件/软件接口，David A. Patterson 和 John L. Hennessy，第 4 版，Morgan Kaufmann，Elsevier，2009 年。
Computer Architecture – A Quantitative Approach，John L. Hennessy 和 David A. Patterson，第 5 版，Morgan Kaufmann，Elsevier，2011。
```
