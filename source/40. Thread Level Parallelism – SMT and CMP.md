# 40. Thread Level Parallelism – SMT and CMP
```text
线程级并行 – SMT 和 CMP
AP SHANTHI博士

 

本模块的目标是讨论 ILP 的缺点以及探索应用程序中可用的其他类型的并行性并利用它们的必要性。我们将讨论线程级并行的含义，并讨论同时多线程和芯片多处理器的概念。

 

   到目前为止，我们已经研究了利用 ILP 的各种硬件和软件技术。我们在流水线实现中可以预期的理想 CPI 仅为 1。我们研究了不同的技术来避免或最小化与各种危险相关的停顿。可以通过加深流水线或加宽流水线来提高流水线实现的性能。深化流水线会增加执行中指令的数量并减少连续独立指令之间的差距。然而，它增加了依赖指令之间的差距。根据程序中的 ILP 存在最佳流水线深度，这是一个设计问题。管道某些结构可能很困难，并且可能会增加绕过的成本。增加管道的宽度，在多问题的情况下，处理器也有自己的问题和困难。可能很难找到多于几个，例如，四个独立的指令来发出，并且可能难以获取多于六个的指令，并且每个结构的端口数量也有所增加。

 

    为了减少与获取相关的停顿，我们可能必须采用更好的分支预测方法，以及索引/更新和避免混叠以及级联分支预测器的新方法。另一种选择是使用跟踪缓存. 跟踪缓存不是将静态缓存块中的指令限制为空间局部性，而是查找动态指令序列，包括加载到缓存块中的分支。该名称来自缓存块，其中包含由 CPU 确定的已执行指令的动态跟踪，而不是包含由内存确定的静态指令序列。因此，分支预测被折叠到缓存中，并且必须与地址一起验证以获得有效的提取。作为 Pentium 4 及其后续产品的基础的 Intel Netburst 微体系结构使用跟踪缓存。跟踪缓存有很多缺点，但在处理获取单元的限制方面非常有用。在 Intel 处理器中，跟踪缓存存储预解码的指令。

 

ILP 的局限性：尽管采用了所有用于利用 ILP 的硬件和软件技术，但我们可以利用 ILP 的程度是有限的。首先，我们使用的硬件是有限制的。我们实际拥有的虚拟寄存器的数量是有限的，而不是无限的，以进行重命名过程。我们使用的分支预测器和跳转预测器可能并不完美。同样，我们可能无法始终解决内存地址歧义问题。简而言之，我们没有理想化的处理器，只受真实数据依赖性的限制，没有任何控制、WAR 和 WAW 危害。

 

将今天的每时钟 3-6 条指令的问题率加倍，比如 6 到 12 条指令，可能需要处理器每个周期发出 3 或 4 次数据存储器访问，每个周期解析 2 或 3 个分支，重命名和访问每个周期超过 20 个寄存器周期，每个周期取 12 到 24 条指令。实现这些功能的复杂性很可能意味着牺牲最大时钟速率。例如，问题最广泛的处理器之一是安腾 2，但它的时钟频率也最慢，尽管它消耗的功率最大。大多数提高性能的技术也会增加功耗。多问题处理器技术都是低能效的。发出多条指令会导致逻辑上的一些开销增长得快于发出率的增长。

 

利用其他类型的并行性：上述讨论清楚地表明，在某些应用程序中，ILP 可能非常有限或难以利用。更重要的是，它可能会导致功耗的增加。此外，可能在应用程序的更高级别自然发生显着的并行性，而这些并行性无法通过用于利用 ILP 的方法来利用。例如，在线事务处理系统在请求呈现的多个查询和更新之间具有自然的并行性。这些查询和更新大多可以并行处理，因为它们在很大程度上相互独立。这种更高级别的并行性称为线程级并行性，因为它在逻辑上被构造为单独的执行线程。一个线程是一个独立的过程，有自己的指令和数据。一个线程可以代表一个进程，该进程是由多个进程组成的并行程序的一部分，或者它可以代表一个独立的程序。每个线程都拥有允许其执行所需的所有状态（指令、数据、PC、寄存器状态等）。与在循环或直线代码段内利用隐式并行操作的指令级并行不同，线程级并行通过使用多个本质上并行的执行线程来明确表示。

 

线程级并行是指令级并行的重要替代方案，主要是因为它比指令级并行更具成本效益。有许多重要的应用程序自然发生线程级并行，就像在许多服务器应用程序中一样。类似地，许多应用程序自然地利用数据级并行性，其中可以对多个数据执行相同的操作。我们将在后面的模块中讨论如何利用数据级并行性。

 

由于 ILP 和 TLP 在程序中利用两种不同类型的并行结构，因此将这两种类型的并行性结合起来是很自然的选择。已经设计的数据路径有许多功能单元保持空闲，因为停顿和依赖性导致 ILP 不足。这可用于利用 TLP，从而使功能单元忙碌。主要有两种利用 TLP 和 ILP 的策略——多线程及其变体，即同步多线程 (SMT)和芯片多处理器 (CMP). 在 SMT 的情况下，多个线程共享同一个大型处理器，这减少了利用率不足并进行了有效的资源分配。在CMPs的情况下，每个线程都在自己的微型处理器上执行，这导致设计简单，线程之间干扰低。我们将讨论这两种方法。

 

多线程：多线程允许多个线程以重叠的方式共享单个处理器的功能单元。为了实现这一点，处理器复制每个线程的独立状态——寄存器文件的单独副本、单独的 PC 和单独的页表。内存本身可以通过已经支持多道程序的虚拟内存机制共享。此外，硬件必须支持相对较快地切换到不同线程的能力；特别是，线程切换应该比进程切换更有效率，进程切换通常需要数百到数千个处理器周期。

 

多线程有两种主要方法——细粒度和粗粒度。细粒度的多线程在每条指令上的线程之间切换，导致多个线程的执行交错​​。这种交织通常以循环方式完成，跳过当时停滞的任何线程。为了支持这一点，CPU 必须能够在每个时钟周期切换线程。细粒度多线程的主要优点是它可以隐藏由短停顿和长停顿引起的吞吐量损失，因为当一个线程停顿时可以执行来自其他线程的指令。但它会减慢单个线程的执行速度，因为一个准备好执行而没有停顿的线程将被其他线程的指令延迟。

 

粗粒度多线程 仅在代价高昂的停顿（例如二级缓存未命中）上切换线程。这为线程切换留出了一些时间，并且不太可能降低处理器的速度，因为只有在线程遇到代价高昂的停顿时才会发出来自其他线程的指令。然而，粗粒度多线程在克服吞吐量损失的能力方面受到限制，尤其是由于较短的停顿。这种限制源于粗粒度多线程的管道启动成本。因为具有粗粒度多线程的 CPU 从单个线程发出指令，当发生停顿时，必须清空或冻结管道，然后从新线程填充指令。由于这种启动开销，粗粒度多线程对于减少高成本停顿的惩罚更有用，

 

同步多线程：这是多线程的一种变体。当我们只从一个线程发出指令时，可能没有足够的并行性，并且可能无法使用所有功能单元。相反，如果我们在同一时钟周期内从多个线程发出指令，我们将能够更好地利用功能单元。这就是并发多线程的概念。我们尝试使用多问题的资源、动态调度的超标量来利用 ILP 之上的 TLP。动态调度的处理器已经有很多支持多线程的硬件机制——

一大组虚拟寄存器，可用于保存独立线程的寄存器组
寄存器重命名以提供唯一的寄存器标识符，以便可以在数据路径中混合来自多个线程的指令，而不会混淆跨线程和
乱序完成，允许线程乱序执行，并更好地利用硬件。
 

因此，通过寄存器重命名和动态调度，可以发出来自独立线程的多条指令，而无需考虑它们之间的依赖关系。依赖关系的解决将由动态调度能力处理。我们需要为每个线程添加一个重命名表并保留单独的 PC。每个线程的独立承诺可以通过逻辑上为每个线程保留一个单独的重新排序缓冲区来支持。图 24.1 显示了各种技术之间的差异。

 

在没有多线程支持的超标量方法中，每个时钟周期发出的指令数量取决于可用的 ILP。此外，重大停顿（例如指令高速缓存未命中）可能会使整个处理器处于空闲状态。在细粒度的情况下，线程的交错消除了完全空的插槽。然而，因为在给定的时钟周期内只有一个线程发出指令，ILP 的限制仍然导致在单个时钟周期内有大量的空闲时隙。在粗粒度的多线程超标量中，通过切换到另一个使用处理器资源的线程来部分隐藏长停顿。虽然这减少了完全空闲时钟周期的数量，但在每个时钟周期内，ILP 限制仍然导致空闲周期。此外，在粗粒度的多线程处理器中，由于线程切换仅在出现停顿且新线程有启动期时才会发生，因此可能会有一些完全空闲的周期。在 SMT 情况下，TLP 和 ILP 被同时利用，多个线程在单个时钟周期内使用问题槽。理想情况下，问题槽的使用受到资源需求和多线程资源可用性不平衡的限制。在实践中，其他因素——包括考虑了多少活动线程、缓冲区的有限限制、从多个线程获取足够指令的能力以及从一个线程和多个线程发出指令组合的实际限制——也可以限制如何使用了许多插槽。可能会有一些完全空闲的周期。在 SMT 情况下，TLP 和 ILP 被同时利用，多个线程在单个时钟周期内使用问题槽。理想情况下，问题槽的使用受到资源需求和多线程资源可用性不平衡的限制。在实践中，其他因素——包括考虑了多少活动线程、缓冲区的有限限制、从多个线程获取足够指令的能力以及从一个线程和多个线程发出指令组合的实际限制——也可以限制如何使用了许多插槽。可能会有一些完全空闲的周期。在 SMT 情况下，TLP 和 ILP 被同时利用，多个线程在单个时钟周期内使用问题槽。理想情况下，问题槽的使用受到资源需求和多线程资源可用性不平衡的限制。在实践中，其他因素——包括考虑了多少活动线程、缓冲区的有限限制、从多个线程获取足够指令的能力以及从一个线程和多个线程发出指令组合的实际限制——也可以限制如何使用了许多插槽。问题槽的使用受到资源需求和多线程资源可用性不平衡的限制。在实践中，其他因素——包括考虑了多少活动线程、缓冲区的有限限制、从多个线程获取足够指令的能力以及从一个线程和多个线程发出指令组合的实际限制——也可以限制如何使用了许多插槽。问题槽的使用受到资源需求和多线程资源可用性不平衡的限制。在实践中，其他因素——包括考虑了多少活动线程、缓冲区的有限限制、从多个线程获取足够指令的能力以及从一个线程和多个线程发出指令组合的实际限制——也可以限制如何使用了许多插槽。

 


 

            为了利用 TLP 和 ILP，我们需要讨论的另一个选项是芯片多处理器 (CMP)。与其看一个强大的处理器，它可能是一个支持推测和 SMT 的动态调度超标量，我们可以看看一个更简单的处理器，但它们的倍数吗？这就是 CMPs 的含义——单个芯片上的多个处理器。每个处理器可以单独支持一个执行线程。因此，对于多个处理器，我们有多个执行线程。这些处理器可以具有共享和分布式内存架构，并且它们可以由同构和异构处理器类型组成。在同一芯片上拥有多个处理器可减少连线延迟。由于处理器在大多数情况下只是复制（同构），避免了现代复杂处理器所需的非常长的设计和验证时间。SMT 处理器和 CMP 之间的区别可以总结如下：

 

贴片：

执行单元池（宽机）
几个逻辑处理器
– 每个逻辑处理器的状态副本
– 多个线程并发运行
– 更好的利用率和延迟容忍度
CMP：

简单的核心
– 适度的并行度
– 线程在不同的内核上并发运行
芯片多处理器在单个芯片上集成多个处理器内核
减轻打包和互连多个处理器的物理挑战
这种紧密集成减少了片外信号并导致处理器到处理器通信和同步的延迟降低。
CMP 使用相对简单的单线程处理器内核，通过跨多个处理器内核并行执行多个线程来利用一个应用程序的线程级并行性。
允许相当短的循环时间。
减少硬件开销。
降低功耗。
CMP 是运行多道程序工作负载或多线程应用程序的理想平台。但是，如果应用程序不能有效分解为线程或没有足够的 TLP，则 CMP 架构可能会导致资源浪费。
 

总而言之，我们研究了 ILP 的局限性以及利用其他类型的并行性（如 TLP 和数据级并行性）的必要性。基本上有两种利用 TLP 的方法——多线程和 CMP。我们讨论了不同类型的多线程——细粒度多线程、粗粒度多线程和同步多线程。与使用复杂的处理器不同，另一种选择是查看执行多个执行线程的简单的多处理器。我们还讨论了这两种处理器之间的比较。

网页链接/支持材料
计算机组织与设计——硬件/软件接口，David A. Patterson 和 John L. Hennessy，第 4 版，Morgan Kaufmann，Elsevier，2009 年。
Computer Architecture – A Quantitative Approach，John L. Hennessy 和 David A. Patterson，第 5 版，Morgan Kaufmann，Elsevier，2011。
```
