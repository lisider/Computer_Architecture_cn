# 23. Cache Optimizations I
```text
缓存优化我
AP SHANTHI博士

 

本模块的目标是讨论影响分层内存系统中平均内存访问时间的各种因素，并讨论一些可以用来改进它的技术。

 

前面的模块讨论了对分层内存系统的需求，以满足处理器的速度、容量和成本要求，以及如何使用高速缓存来隐藏与主内存访问相关的延迟。我们还研究了高速缓存中采用的各种映射策略和读/写策略。

 

内存访问时间：为了查看缓存的性能，我们需要查看平均内存访问时间以及会影响它的因素。平均内存访问时间 (AMAT) 定义为

 

AMAT = htc + (1 – h) (tm + tc)，其中第二项中的 tc 通常被忽略。

 

h : 缓存命中率

tc : 缓存访问时间

1 – h : 缓存未命中率

tm : 主存访问时间

 

AMAT 可以写为命中时间 +（未命中率 x 未命中惩罚）。减少这些因素中的任何一个都会降低 AMAT。可以很容易地观察到，当缓存的命中率接近 1（即 100%）时，所有引用都指向缓存，内存访问时间仅由缓存系统控制。那么只有缓存性能很重要。另一方面，如果我们在缓存中未命中，则未命中惩罚，即主内存访问时间也很重要。因此，所有三个因素都会影响 AMAT，并且可以进行优化以减少这些参数中的一个或多个。

 

有多种不同的方法可用于降低 AMAT。大约有 18 种不同的缓存优化，它们分为 4 类，如下所示：

 

Ø 减少失误惩罚：

 

§ 多级缓存，关键词优先，读未命中优先于写未命中，合并写缓冲区条目和牺牲缓存

 

Ø 降低漏检率

    § 更大的块大小、更大的缓存大小、更高的关联性、路预测和伪关联性以及编译器优化

 

Ø 通过并行性降低未命中惩罚或未命中率

 

§ 非阻塞缓存、多组缓存、硬件和编译器预取

 

Ø 减少命中缓存的时间

 

§ 小而简单的缓存，避免地址转换、流水线缓存访问和跟踪缓存

 

在本模块中，我们将讨论可用于减少未命中惩罚的技术。处理失误的时间越来越成为控制因素。这是因为与内存速度相比，处理器的速度有了很大的提高。可用于解决提高 Miss Penalty 问题的五个优化是：

 

• 多级缓存

 

• 关键词优先和提前重启

 

• 读取未命中优先于写入

 

• 合并写缓冲区

 

• 受害者缓存

 

我们将详细研究每一个。

 

多级缓存：我们讨论的第一种技术和最广泛使用的技术之一是使用多级缓存，而不是单个缓存。当我们有单级缓存时，我们应该决定是让缓存更快以跟上 CPU 的速度，还是让缓存更大以克服 CPU 和主存之间不断扩大的差距。这两种情况都可以通过引入多一级缓存来处理。因此，在原始缓存和内存之间添加另一级缓存可以简化决策。一级缓存可以足够小，以匹配快速 CPU 的时钟周期时间。然而，二级缓存可以足够大以捕获许多将进入主存储器的访问，从而减少有效的未命中惩罚。

 

使用两级缓存，必须适当更改 AMAT。使用下标L1和L2分别指代一级缓存和二级缓存，原公式为

 

平均内存访问时间 = 命中时间 L1 + 未命中率 L1 x 未命中率 L1 但是，未命中率 L1 = 命中时间 L2 + 未命中率 L2 x 未命中率 L2

 

因此，平均内存访问时间 = Hit TimeL1 + Miss RateL1 x（Hit TimeL2 + Miss RateL2 x Miss PenaltyL2）

 

我们可以定义两种不同的未命中率——局部未命中率和全局未命中率。本地未命中率— 缓存中的未命中数除以对该缓存的内存访问总数（未命中率L2）。全局未命中率— 缓存中的未命中数除以 CPU 生成的内存访问总数（Miss RateL1 x Miss RateL2）。

 

二级缓存的本地未命中率很大，因为一级缓存略去了内存访问的精华。这就是为什么全局未命中率是一个更有用的衡量标准：它表明离开处理器的内存访问有多少一直到内存。但是，缺点是它需要额外的硬件。

 

图 27.1 给出了多级缓存的未命中率与缓存大小的关系。可以观察到全局缓存未命中率与二级缓存的单个缓存未命中率非常相似，前提是二级缓存远大于一级缓存。二级缓存的未命中率是一级缓存未命中率的函数，因此可以通过更改一级缓存而变化。因此，在评估二级缓存时应使用全局缓存未命中率。

 


图 27.2 显示了相对执行时间与二级缓存大小的关系。观察到一级缓存的速度会影响处理器的时钟频率，而二级缓存的速度只影响一级缓存的未命中惩罚。一个主要决定是二级缓存的大小 。由于一级缓存中的所有内容都可能在二级缓存中，因此二级缓存应该比一级缓存大得多。如果二级缓存稍微大一点，本地未命中率就会很高。这一观察启发了巨大的二级缓存的设计。此外，提高二级缓存的关联性将提高性能。


 

Early Restart 和Critical Word First：这项技术是基于观察到处理器通常一次只需要一个块的一个字，这表明我们不必在发送请求之前等待完整块被加载word 并重新启动处理器。具体有两种策略：

 

关键字优先——从内存中请求确切的字，并在它到达时立即将其发送到处理器，以便处理器在读取块中的其余字时继续执行。它也被称为包装提取和请求词优先。

 

提前重启——按正常顺序取字，但是一旦块的请求字到达，就将其发送给处理器，让处理器继续执行。

 

通常，这些技术仅有益于具有大缓存块的设计，因为小块的收益较低。请注意，当块的其余部分正在被填充时，缓存通常会继续满足对其他块的访问。有了空间局部性，下一个参考很有可能是块的其余部分，并且未命中惩罚不是很容易计算。当第一个关键词中有第二个请求时，有效的未命中惩罚是从引用到第二个片段到达的非重叠时间。因此，关键字优先和提前重启的好处取决于 块的大小以及对块中尚未提取的部分进行另一次访问的可能性。

 

读未命中优先于写：在前面的模块中，我们已经指出了写缓冲区的用法。将要写入主存储器的数据写入写入缓冲区，处理器访问继续。这里建议的优化通常是通过写缓冲区完成的。然而，写缓冲区确实使内存访问变得复杂，因为它们可能保存读取未命中所需位置的更新值。这将导致RAW危害。处理此问题的最简单方法是等待读未命中，直到写缓冲区为空。另一种选择是在读取未命中时检查写入缓冲区的内容，如果没有冲突且内存系统可用，则允许读取未命中继续。大多数处理器使用第二种方法，因此读取优先于写入。

 

这种优化对于写回缓存也很有效。假设读取未命中必须替换脏内存块。我们可以将脏块复制到写入缓冲区，然后读取内存，然后写入内存，而不是将脏块写入内存，然后读取内存。这样处理器读取将完成得更快。但是，必须妥善处理 RAW 危害。

 

合并写入缓冲区条目：这是用于提高写入缓冲区效率的优化。通常，如果写缓冲区为空，则数据和完整地址将写入缓冲区。CPU 继续工作，而缓冲区准备将字写入内存。现在，如果缓冲区包含其他修改过的块，则可以检查地址以查看此新数据的地址是否与有效写入缓冲区条目的地址匹配。如果是这样，新数据可以与已经可用的条目组合，称为写入合并。如图 27.3 所示。第一个图显示了没有合并的写缓冲区条目。第二张图显示了合并写入缓冲区条目的效果。地址 100、108、116 和 124 是连续地址，因此它们已合并为一个条目。


 

这种优化可以更有效地使用内存，因为多字写入通常比一次执行一个字的写入速度更快。它还减少了由于写缓冲区已满而导致的停顿。如果写缓冲区已满并且没有地址匹配，则缓存（和 CPU）必须等到缓冲区有一个空条目。Sun Niagara 处理器是使用写合并的处理器之一。但是，I/O 地址不能允许写入合并，因为单独的 I/O 寄存器可能不像内存中的字数组那样起作用。

 

受害者缓存：我们在本模块中讨论的最后一项减少未命中惩罚的技术是使用受害者缓存。降低未命中惩罚的一种方法是记住丢弃的内容，以防再次需要。例如，在直接映射中，如果再次需要丢弃的块。这种回收需要在缓存与其再填充路径之间有一个小的、完全关联的缓存——称为受害者缓存，因为它存储了驱逐策略的受害者。受害者缓存仅包含因未命中而从缓存中丢弃的块——“受害者”——并在未命中时检查它们是否具有所需的数据，然后再进入下一个较低级别的内存。如果找到，则交换牺牲块和缓存块。图 27.4 显示了受害者缓存的位置。

 

通常，在回写缓存中，被替换的块有时称为牺牲品。因此，AMD Opteron 将其写入缓冲区称为牺牲缓冲区。AMD Athlon 有一个有八个条目的受害者缓存。写牺牲缓冲区或牺牲缓冲区包含由于未命中而从缓存中丢弃的脏块。不是在随后的高速缓存未命中时停止，而是在未命中时检查缓冲区的内容，以查看它们是否具有所需的数据，然后再进入下一个较低级别的存储器。在 与写缓冲区相反，受害缓存可以包含任何在未命中时从缓存中丢弃的块，无论它们是否脏。虽然写缓冲区的目的是允许缓存继续进行，而无需等待脏块写入内存，但受害者缓存的目标是减少冲突未命中的影响。尽管在标题中使用“受害者”会引起混淆，但写入缓冲区今天比受害者缓存更受欢迎。

 


 

总而言之，我们在这个模块中定义了平均内存访问时间。AMAT 取决于命中时间、未命中率和未命中惩罚。存在多种优化来处理这些因素中的每一个。我们讨论了减少未命中惩罚的五种不同技术。他们是：

多级缓存
提前重启和关键词优先
读未命中优先于写未命中
合并写缓冲区条目和
受害者缓存
 

网页链接/支持材料

计算机组织与设计——硬件/软件接口，David A. Patterson 和 John L. Hennessy，第 4 版，Morgan Kaufmann，Elsevier，2009 年。
Computer Architecture – A Quantitative Approach，John L. Hennessy 和 David A.Patterson，第 5 版，Morgan Kaufmann，Elsevier，2011。
计算机组织，Carl Hamacher、Zvonko Vranesic 和 Safwat Zaky，第 5 版，McGraw-Hill 高等教育，2011 年。
```
